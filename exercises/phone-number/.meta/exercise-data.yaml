exercise: PhoneNumber
plan: 19
subs: clean_number
tests: |-
  my @cases =
      map {
          $_->[2] .= ' - ' . $_->[0];
          $_;
      }
      map {
          my @test = ( $_->{input}{phrase}, $_->{expected}, $_->{description} );

          if ( ref $test[1] ) {
              $test[1] = $test[1]->{error};
              push @test, 1;
          }

          \@test;
      }
      map { @$_ }
      map { $_->{cases} }
      map { @$_ }
          $C_DATA->{cases};

  $_->[3] ? error_test(@$_) : regular_test(@$_) for @cases;

  sub regular_test {
      my( $input, $expected, $desc ) = @_;
      is clean_number($input), $expected, $desc;
  }

  sub error_test {
      my( $input, $error, $desc ) = @_;
      like dies( sub { clean_number($input) } ), qr/$error/, $desc;
  }

example: |
  sub clean_number {
    my ($number) = @_;
    $number =~ s/[()-. ]//g;
    if ($number =~ /^ 1? (\d{10}) $/x) {
      for ([area => substr($1, 0, 1)], [exchange => substr($1, 3, 1)]) {
        die $_->[0] . ' code cannot start with ' . ($_->[1] ? 'one' : 'zero') if $_->[1] < 2;
      }
    }
    else {
      die 'more than 11 digits'        if length $number > 11;
      die 'incorrect number of digits' if length $number < 10;
      die 'letters not permitted'      if $number =~ /[a-z]/i;
      die 'punctuations not permitted' if $number =~ /\W/;
      die '11 digits must start with 1';
    }
    return $1;
  }

stub: |
  sub clean_number {
    my ($number) = @_;
    return undef;
  }
