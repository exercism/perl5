methods: is_empty contains is_subset_of is_disjoint_of is_equal_to add intersection difference union
moo: true
tests: |
  my ($set, $set1, $set2);
properties:
  empty:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', dmp($case->{input}{set}), $case->{expected} ? 'T' : 'DF', dmp($case->{description}));
      $set = CustomSet->new(elements => %s);
      is(
          $set->is_empty,
          %s,
          %s,
      );
      END
  contains:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', dmp($case->{input}{set}), $case->{input}{element}, $case->{expected} ? 'T' : 'DF', dmp($case->{description}));
      $set = CustomSet->new(elements => %s);
      is(
          $set->contains( %s ),
          %s,
          %s,
      );
      END
  subset:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', (map {dmp($_)} @{$case->{input}}{qw<set1 set2>}), $case->{expected} ? 'T' : 'DF', dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->is_subset_of( $set2 ),
          %s,
          %s,
      );
      END
  disjoint:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', (map {dmp($_)} @{$case->{input}}{qw<set1 set2>}), $case->{expected} ? 'T' : 'DF', dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->is_disjoint_of( $set2 ),
          %s,
          %s,
      );
      END
  equal:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', (map {dmp($_)} @{$case->{input}}{qw<set1 set2>}), $case->{expected} ? 'T' : 'DF', dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->is_equal_to( $set2 ),
          %s,
          %s,
      );
      END
  add:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', dmp($case->{input}{set}), $case->{input}{element}, dmp($case->{expected}), dmp($case->{description}));
      $set = CustomSet->new(elements => %s);
      is(
          $set->add( %s ),
          CustomSet->new(elements => %s),
          %s,
      );
      END
  intersection:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', (map {dmp($_)} @{$case->{input}}{qw<set1 set2>}, $case->{expected}), dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->intersection( $set2 ),
          CustomSet->new(elements => %s),
          %s,
      );
      END
  difference:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', (map {dmp($_)} @{$case->{input}}{qw<set1 set2>}, $case->{expected}), dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->difference( $set2 ),
          CustomSet->new(elements => %s),
          %s,
      );
      END
  union:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', map {dmp($_)} @{$case->{input}}{qw<set1 set2>}, $case->{expected}, $case->{description});
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->union( $set2 ),
          CustomSet->new(elements => %s),
          %s,
      );
      END

example: |-
  has elements => (
      is => 'ro',
      coerce => sub {
          if (ref $_[0] eq 'ARRAY') {
              return { map { $_ => 1 } @{$_[0]} };
          }
      },
  );

  sub is_empty {
      my ($self) = @_;
      return !keys %{ $self->elements };
  }

  sub contains {
      my ($self, $element) = @_;
      return $self->elements->{$element} // 0;
  }

  sub is_subset_of {
      my ($self, $set) = @_;
      for my $key (keys %{ $self->elements }) {
          return 0 unless $set->contains($key);
      }
      return 1;
  }

  sub is_disjoint_of {
      my ($self, $set) = @_;
      for my $key (keys %{ $self->elements }) {
          return 0 if $set->contains($key);
      }
      return 1;
  }

  sub is_equal_to {
      my ($self, $set) = @_;
      return 0 if keys %{ $self->elements } != keys %{ $set->elements };
      for my $key (keys %{ $self->elements } ) {
          return 0 unless $set->contains($key);
      }
      return 1;
  }

  sub add {
      my ($self, $element) = @_;
      return __PACKAGE__->new(elements => [keys %{$self->elements}, $element]);
  }

  sub intersection {
      my ($self, $set) = @_;
      return __PACKAGE__->new(elements => [ grep { $self->elements->{$_} && $set->elements->{$_} } keys %{$self->elements}, keys %{$set->elements} ]);
  }

  sub difference {
      my ($self, $set) = @_;
      return __PACKAGE__->new(elements => [ grep { $self->elements->{$_} && !$set->elements->{$_} } keys %{$self->elements} , keys %{$set->elements} ]);
  }

  sub union {
      my ($self, $set) = @_;
      return __PACKAGE__->new(elements => [ keys %{ $self->elements }, keys %{ $set->elements } ]);
  }

stub: |-
  has elements => (
      is => 'ro',
  );

  sub is_empty {
      my ($self) = @_;
      return undef;
  }

  sub contains {
      my ($self, $element) = @_;
      return undef;
  }

  sub is_subset_of {
      my ($self, $set) = @_;
      return undef;
  }

  sub is_disjoint_of {
      my ($self, $set) = @_;
      return undef;
  }

  sub is_equal_to {
      my ($self, $set) = @_;
      return undef;
  }

  sub add {
      my ($self, $element) = @_;
      return undef;
  }

  sub intersection {
      my ($self, $set) = @_;
      return undef;
  }

  sub difference {
      my ($self, $set) = @_;
      return undef;
  }

  sub union {
      my ($self, $set) = @_;
      return undef;
  }
