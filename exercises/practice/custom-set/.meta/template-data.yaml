methods: is_empty contains is_subset_of is_disjoint_of is_equal_to add intersection difference union
moo: true
tests: |
  my ($set1, $set2);
properties:
  empty:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', dmp($case->{input}{set}), $case->{expected} ? 'T' : 'DF', dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      is(
          $set1->is_empty,
          %s,
          %s,
      );
      END
  contains:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', dmp($case->{input}{set}), $case->{input}{element}, $case->{expected} ? 'T' : 'DF', dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      is(
          $set1->contains( %s ),
          %s,
          %s,
      );
      END
  subset:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', (map {dmp($_)} @{$case->{input}}{qw<set1 set2>}), $case->{expected} ? 'T' : 'DF', dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->is_subset_of( $set2 ),
          %s,
          %s,
      );
      END
  disjoint:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', (map {dmp($_)} @{$case->{input}}{qw<set1 set2>}), $case->{expected} ? 'T' : 'DF', dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->is_disjoint_of( $set2 ),
          %s,
          %s,
      );
      END
  equal:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', (map {dmp($_)} @{$case->{input}}{qw<set1 set2>}), $case->{expected} ? 'T' : 'DF', dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->is_equal_to( $set2 ),
          %s,
          %s,
      );
      END
  add:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', dmp($case->{input}{set}), $case->{input}{element}, dmp($case->{expected}), dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      is(
          $set1->add( %s ),
          CustomSet->new(elements => %s),
          %s,
      );
      END
  intersection:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', (map {dmp($_)} @{$case->{input}}{qw<set1 set2>}, $case->{expected}), dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->intersection( $set2 ),
          CustomSet->new(elements => %s),
          %s,
      );
      END
  difference:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', (map {dmp($_)} @{$case->{input}}{qw<set1 set2>}, $case->{expected}), dmp($case->{description}));
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->difference( $set2 ),
          CustomSet->new(elements => %s),
          %s,
      );
      END
  union:
    test: |-
      use Data::Dmp;
      sprintf(<<'END', map {dmp($_)} @{$case->{input}}{qw<set1 set2>}, $case->{expected}, $case->{description});
      $set1 = CustomSet->new(elements => %s);
      $set2 = CustomSet->new(elements => %s);
      is(
          $set1->union( $set2 ),
          CustomSet->new(elements => %s),
          %s,
      );
      END

example: |-
  use Types::Common qw<-types>;
  use namespace::clean;

  has elements => (
      is => 'ro',
      isa => (HashRef[Bool])->plus_coercions(
          ArrayRef, sub { +{ map { $_ => 1 } @{$_[0]} } },
      ),
      coerce => 1,
  );

  has _keys => (
      is => 'lazy',
      builder => sub {
          [ keys %{ $_[0]->elements } ];
      },
  );

  sub is_empty {
      my ($self) = @_;
      return !@{$self->_keys};
  }

  sub contains {
      my ($self, $element) = @_;
      return !!$self->elements->{$element};
  }

  sub is_subset_of {
      my ($self, $set) = @_;
      for my $key (@{ $self->_keys }) {
          return 0 unless $set->contains($key);
      }
      return 1;
  }

  sub is_disjoint_of {
      my ($self, $set) = @_;
      for my $key (@{ $self->_keys }) {
          return 0 if $set->contains($key);
      }
      return 1;
  }

  sub is_equal_to {
      my ($self, $set) = @_;
      return 0 if @{ $self->_keys } != @{ $set->_keys };
      for my $key (@{ $self->_keys } ) {
          return 0 unless $set->contains($key);
      }
      return 1;
  }

  sub add {
      my ($self, $element) = @_;
      return __PACKAGE__->new(elements => [@{$self->_keys}, $element]);
  }

  sub intersection {
      my ($self, $set) = @_;
      return __PACKAGE__->new(elements => [ grep { $self->contains($_) && $set->contains($_) } @{$self->_keys}, @{$set->_keys} ]);
  }

  sub difference {
      my ($self, $set) = @_;
      return __PACKAGE__->new(elements => [ grep { $self->contains($_) && !$set->contains($_) } @{$self->_keys} , @{$set->_keys} ]);
  }

  sub union {
      my ($self, $set) = @_;
      return __PACKAGE__->new(elements => [ @{ $self->_keys }, @{ $set->_keys } ]);
  }

stub: |-
  has elements => (
      is => 'ro',
  );

  sub is_empty {
      my ($self) = @_;
      return undef;
  }

  sub contains {
      my ($self, $element) = @_;
      return undef;
  }

  sub is_subset_of {
      my ($self, $set) = @_;
      return undef;
  }

  sub is_disjoint_of {
      my ($self, $set) = @_;
      return undef;
  }

  sub is_equal_to {
      my ($self, $set) = @_;
      return undef;
  }

  sub add {
      my ($self, $element) = @_;
      return undef;
  }

  sub intersection {
      my ($self, $set) = @_;
      return undef;
  }

  sub difference {
      my ($self, $set) = @_;
      return undef;
  }

  sub union {
      my ($self, $set) = @_;
      return undef;
  }
