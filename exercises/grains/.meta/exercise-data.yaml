exercise: Grains
plan: 12
subs: grains_on_square total_grains
modules:
  - use: Math::BigInt
tests: |-
  my @exception_cases;

  foreach (@{$C_DATA->{cases}}) {
    if (exists $_->{cases}) {
      foreach my $case (@{$_->{cases}}) {
        if ($case->{property} eq 'square') {
          if (ref $case->{expected} eq 'HASH' && $case->{expected}{error}) {
            push @exception_cases, $case;
          }
          else {
            cmp_ok(
              Math::BigInt->new(grains_on_square $case->{input}{square}),
              '==',
              $case->{expected},
              'square no. ' . $case->{description}
            );
          }
        }
      }
    }
    elsif ($_->{property} eq 'total') {
      cmp_ok(
        Math::BigInt->new(total_grains),
        '==',
        $_->{expected},
        $_->{description}
      );
    }
  }

  SKIP: {
    eval { require Test::Fatal };
    skip 'Test::Fatal not loaded', scalar @exception_cases if $@;
    eval q{
      use Test::Fatal qw(exception);
      isnt exception {grains_on_square $_->{input}{square}}, undef, $_->{description} foreach @exception_cases;
    };
  }

example: |-
  use bignum;

  sub grains_on_square {
    my ($square) = @_;
    if ($square < 1 || $square > 64) {
      die 'invalid square';
    }
    return 2 ** ($square - 1);
  }

  sub total_grains {
    my $sum;
    $sum += grains_on_square($_) for 1..64;
    return $sum;
  }

stub: |-
  sub grains_on_square {
    my ($square) = @_;
    return undef;
  }

  sub total_grains {
    return undef;
  }
